/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { Expr: peg$parseExpr },
      peg$startRuleFunction  = peg$parseExpr,

      peg$c0 = function(e) {return e[e.length-1]},
      peg$c1 = function(v, x) {return nap(v,x)},
      peg$c2 = function(x, v, y) {return nap(v[1],x,y)},
      peg$c3 = function(v, x) {return nap(v[0],x)},
      peg$c4 = "(",
      peg$c5 = peg$literalExpectation("(", false),
      peg$c6 = ")",
      peg$c7 = peg$literalExpectation(")", false),
      peg$c8 = function(expr) {return expr;},
      peg$c9 = function(l, a) {return l(...a.filter(e=>e!==";"))},
      peg$c10 = "{",
      peg$c11 = peg$literalExpectation("{", false),
      peg$c12 = "}",
      peg$c13 = peg$literalExpectation("}", false),
      peg$c14 = function(a, b) {a=a??["x","y","z"]; return (...args)=>
        {
          a.forEach((e,i)=>sctx[e]=args[i]);
          let r=typeof b==="function"? b(): b;
          sctx={}; return r;
        }},
      peg$c15 = "[",
      peg$c16 = peg$literalExpectation("[", false),
      peg$c17 = "]",
      peg$c18 = peg$literalExpectation("]", false),
      peg$c19 = function(e) {return e},
      peg$c20 = ";",
      peg$c21 = peg$literalExpectation(";", false),
      peg$c22 = function(v, a) {return [a(v[1])(),(x,y)=>a(v[1])(y)(x)]},
      peg$c23 = function(e) {return e.length===1? e[0]: e},
      peg$c24 = function(es, l) {return [...es.map(x=>x[0]), l]},
      peg$c25 = "\"",
      peg$c26 = peg$literalExpectation("\"", false),
      peg$c27 = /^[^"]/,
      peg$c28 = peg$classExpectation(["\""], true, false),
      peg$c29 = "\"\"",
      peg$c30 = peg$literalExpectation("\"\"", false),
      peg$c31 = function(v) {return v;},
      peg$c32 = "0n",
      peg$c33 = peg$literalExpectation("0n", false),
      peg$c34 = "0N",
      peg$c35 = peg$literalExpectation("0N", false),
      peg$c36 = function() {return null},
      peg$c37 = /^[0-9]/,
      peg$c38 = peg$classExpectation([["0", "9"]], false, false),
      peg$c39 = ".",
      peg$c40 = peg$literalExpectation(".", false),
      peg$c41 = function() {return +text();},
      peg$c42 = peg$anyExpectation(),
      peg$c43 = "`",
      peg$c44 = peg$literalExpectation("`", false),
      peg$c45 = /^[a-zA-Z]/,
      peg$c46 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
      peg$c47 = function(v) {return v.join("");},
      peg$c48 = function() {return ctx[text()]??{t:name, v:text()}},
      peg$c49 = ":",
      peg$c50 = peg$literalExpectation(":", false),
      peg$c51 = function(v) {return v[0];},
      peg$c52 = /^[~!@#$%\^&*_\-+=||<,>.?]/,
      peg$c53 = peg$classExpectation(["~", "!", "@", "#", "$", "%", "^", "&", "*", "_", "-", "+", "=", "|", "|", "<", ",", ">", ".", "?"], false, false),
      peg$c54 = function() {return vbs[text()];},
      peg$c55 = /^[\\\/']/,
      peg$c56 = peg$classExpectation(["\\", "/", "'"], false, false),
      peg$c57 = function() {return advs[text()]},
      peg$c58 = "/",
      peg$c59 = peg$literalExpectation("/", false),
      peg$c60 = /^[^\n]/,
      peg$c61 = peg$classExpectation(["\n"], true, false),
      peg$c62 = function() {return},
      peg$c63 = peg$otherExpectation("whitespace"),
      peg$c64 = /^[ \t\n\r]/,
      peg$c65 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseExpr() {
    var s0, s1;

    s0 = peg$parseTerm();
    if (s0 === peg$FAILED) {
      s0 = peg$parseProj();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDvb();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseArgl();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parse_();
          }
        }
      }
    }

    return s0;
  }

  function peg$parseTerm() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseMvb();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseTerm();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseFactor();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDvb();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseTerm();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c2(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDvb();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseTerm();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseFactor();
        }
      }
    }

    return s0;
  }

  function peg$parseFactor() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$parseList();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpr();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c6;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseProj();
        if (s0 === peg$FAILED) {
          s0 = peg$parseDvb();
        }
      }
    }

    return s0;
  }

  function peg$parseProj() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseLamd();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseArgl();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseLamd();
    }

    return s0;
  }

  function peg$parseLamd() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c10;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c11); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseArgl();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseExpr();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArgl() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c15;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c16); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseArglT();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseArglT();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c17;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArglT() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 59) {
      s0 = peg$c20;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c21); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseExpr();
    }

    return s0;
  }

  function peg$parseDvb() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseVb();
    if (s1 === peg$FAILED) {
      s1 = peg$parseMvb();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseAdv();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c22(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseVb();
      if (s0 === peg$FAILED) {
        s0 = peg$parseMvb();
      }
    }

    return s0;
  }

  function peg$parseList() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseAtom();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseAtom();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c23(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseStr();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseExpr();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c20;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseExpr();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s5 = peg$c20;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s4 = peg$c6;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c24(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseStr() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c25;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c27.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s3 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c29) {
          s3 = peg$c29;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c29) {
            s3 = peg$c29;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c25;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAtom() {
    var s0;

    s0 = peg$parseNull();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNum();
      if (s0 === peg$FAILED) {
        s0 = peg$parseChar();
        if (s0 === peg$FAILED) {
          s0 = peg$parseSym();
          if (s0 === peg$FAILED) {
            s0 = peg$parseName();
          }
        }
      }
    }

    return s0;
  }

  function peg$parseNull() {
    var s0, s1;

    if (input.substr(peg$currPos, 2) === peg$c32) {
      s0 = peg$c32;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c33); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c34) {
        s1 = peg$c34;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c36();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseNum() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c39;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c40); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c41();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseChar() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c25;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c25;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSym() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c43;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c44); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseStr();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseName() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c45.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c46); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c48();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseMvb() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseVb();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c49;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c51(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVb() {
    var s0, s1;

    s0 = peg$currPos;
    if (peg$c52.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c53); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c54();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseAdv() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (peg$c55.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c56); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c49;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseComment() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c58;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c59); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c60.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c62();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c64.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c65); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c64.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c65); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c62();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c63); }
    }

    return s0;
  }


  // util
  const nump= x=> typeof x==='number'
  const strp= x=> typeof x==='string'
  const arrp= x=> Array.isArray(x)
  const funp= x=> typeof x==='function'
  const a= x=> null==x || !x.length || typeof x=="string";                            // atom?
  const b= x=> +x;                                                                    // bool to int
  const c= x=> typeof x=="string"? x.charCodeAt(0): x;                                // char arithmetic
  const cmp= (x,y)=> (x>y)-(x<y)                                                      // compare
  const cp2= (x,y)=> [].concat(...x.map(a=> y.map(b=>[].concat(a,b))));               // pairwise cartesian product
  const cp= (x,y,...z)=> (y? cp(cp2(x,y),...z): x);                                   // cartesian product
  const t= x=> x[0].map((c,i)=> x.map(r=>r[i]));                                      // transpose
  const vv= x=> a(x)? [x]: x;                                                         // vectorize
  const vv2= x=> a(x)? [[x]]: x.map(e=>vv(e));                                        // vectorize 2 layers
  const bv1= (f,x)=> a(x)? f(x): x.map(n=>bv1(f,n));                                  // broadcast monadic
  const bv= (f,x,y)=>                                                                 // broadcast
    a(x)&&a(y)? f(x,y):                                                               //
      a(x)? y.map(n=>bv(f,x,n)):                                                      //
      a(y)? x.map(n=>bv(f,n,y)):                                                      //
      // x.length==1? y.map(n=>bv(f,x[0],n)):   //unbased
      // y.length==1? x.map(n=>bv(f,n,y[0])):
      x.length==y.length? x.map((n,i)=>bv(f,n,y[i])):                                 //
      (()=> {throw new Error("length")})();                                           //
  const sv= (f,x)=>                                                                   // js string op
    bv1(x=>typeof x=="string"? x.split(""): x, f(x.join("")));                        //
  const c2s = x=> {                                                                   // consecutive chars to strings
    let res=[], buf=[], pb= ()=>buf.length&&res.push(buf.join("")),                   //
      pe= e=>{pb(); buf=[]; res.push(e);}                                             //
    x.forEach(e=> !e.length || typeof e=="string"&&e.length>1?                        //
      pe(e): e.length==1? buf.push(e): pe(c2s(e))); pb();                             //
    return res.map(e=> e.length==1&&typeof e[0]=="string"? e[0]: e);                  //
  }
  const eq= (x,y)=> x===y || !a(x) && x.length==y.length                              // deep equality
    && vv(x).every((e,i)=> eq(e, y[i]));                                              //
  const fl= x=> a(x)? x: [].concat(...x.map(e=> a(e)? e: fl(e)));                     // flatten
  const z= (x,y)=> x.map((e,i)=> [e,y[i]]);                                           // zip
    
  // adverbs
  const ec= f=> x=> x.map(f);                                                         // '
  const ec2= f=> y=> x=> x.map(e=>f(e,y));                                            // '
  const bin= x=> y=> bv1(e=>{                                                         // X'
    for(let i=0; i<x.length; i++){if(e<x[i])return i-1;} return x.length-1;           //
  },y);                                                                               //
  const rd= f=> y=> x=> y===undefined? x.reduce(f): x.reduce(f, y)                    // /
  const jn= (x,y)=> sv(y=>y.join(x), y);                                              // /
  const dec= (x,y) => {                                                               // /
    let r=0, n=1;                                                                     //
    for (let i=x.length-1; i>=0; i--) {r+=y[i]*n; n*=x[i];} return r;                 //
  }
  const fr= f=> n=> x=> {for(let i=0; i<n; i++)x=f(x); return x;}                     // i f/
  const wl= f=> g=> x=> {while(g(x))x=f(x); return x;}                                // f f/
  const cvg= f=> x=> {                                                                // f/
    let a=f(x), b; while (!eq(a,b)&&!eq(a,x)) {b=a; a=f(a);} return a;                //
  }                                                                                   //
  const sc= f=> y=> x=> x.map(e=>y=y===undefined? e: f(y,e));                         // \
  const sp= (x,y)=> sv(y=>y.split(x), y);                                             // \
  const enc= (x,y)=> x.reverse()                                                      // \
    .reduce((a,b)=>{a.unshift(y%b);y=Math.floor(y/b);return a;},[]);                  //
  const fsc= f=> n=> x=> {                                                            // i f\
    let a=[x]; for(let i=0; i<n; i++){x=f(x);a.push(x)}; return a;                    //
  }                                                                                   //
  const wsc= f=> g=> x=> {                                                            // f f\
    let a=[x]; while(g(x)){x=f(x);a.push(x);} return a;                               //
  }                                                                                   //
  const csc= f=> x=> {                                                                // f\
    let a=f(x), r=[x,a], b; while(!eq(a,b)&&!eq(a,x)){b=a; a=f(a); r.push(a);}        //
    return r;                                                                         //
  }                                                                                   //
  const ecr= f=> y=> x=> y.map(e=>f(e,x));                                            // /:
  const ecl= f=> y=> x=> x.map(e=>f(e,y));                                            // \:
  const st= f=> n=> x=> x.reduce((a,_,i,r)=> i+n>r.length? a:                         // i f':
    a.concat([f(r.slice(i,i+n))]),[]);                                                //
  const wd= n=> x=> st(x=>x)(n)(x);                                                   // i':
  const ecp= f=> y=> x=>                                                              // ':
    z(x, [y===undefined? null: y,...x]).map(e=>f(e[0],e[1]));

  // verbs
  const s= x=> x;                                                                     // ::
  const r= (x,y)=> y;                                                                 // :
  const flp= x=> t(vv2(x))                                                            // +
  const add= (x,y)=> bv((x,y)=>c(x)+c(y), x, y);                                      // +
  const neg= x=> bv1(x=>-x, x);                                                       // -
  const sub= (x,y)=> bv((x,y)=>c(x)-c(y), x, y);                                      // -
  const fst= x=> Array.isArray(x)? x[0]: x;                                                                // *
  const mul= (x,y)=> bv((x,y)=>x*y, x, y);                                            // iI*iI, not defined for chars
  const srt= x=> bv1(x=>Math.sqrt(x), x)                                              // %
  const div= (x,y)=> bv((x,y)=>x/y, x, y);                                            // iI%iI, not defined for chars
  const od= v=> cp(...vv(v).map(n => [...Array(n).keys()]));                          // !iI, would be +! in ngn/k
  const k= Object.keys;                                                               // !
  const d= (x,y)=> Object.fromEntries(x.map((k,i)=> [k,y[i]]));                       // !
  const dm= (x,y)=> x>0? y%x: Math.floor(y/x);                                        // i!I, div or mod
  const wh= x=> [].concat(...vv(x).map((e,i)=> e.length? [wh(e)]: Array(e).fill(i))); // &
  const min= (x,y)=> bv((x,y)=>Math.min(x,y), x, y);                                  // &
  const rev= x=> vv(x).reverse();                                                     // |
  const max= (x,y)=> bv((x,y)=>Math.max(x,y), x, y);                                  // |
  const asc= x=> [...vv(x).keys()].sort((a,b)=> cmp(x[a],x[b]));                      // <
  const lt= (x,y)=> bv((x,y)=>b(x<y), x, y);                                          // <
  // nyi file/web open & close
  const dsc= x=> [...vv(x).keys()].sort((a,b)=> -cmp(x[a],x[b]));                     // >
  const gt= (x,y)=> bv((x,y)=>b(x>y), x, y);                                          // >
  const umt= x=> [...Array(x).keys()]                                                 // =i, unit matrix
    .map(i=> [].concat(Array(i).fill(0), 1, Array(x-i-1).fill(0)));                   //
  const grp= x=> vv(x).reduce((t,e)=>{t[e]? t[e]++: t[e]=1; return t;}, {});          // =
  const eql= (x,y)=> bv((x,y)=>b(x===y), x, y);                                       // =
  const not= x=> bv1(x=>b(!x), x);                                                    // ~
  const mch= (x,y)=> b(eq(x,y));                                                      // ~
  const enl= x=> [x];                                                                 // ,
  const cat= (x,y)=> x.concat(y);                                                  // ,
  const nul= x=> bv1(x=>b(null==x), x);                                               // ^
  const fll= (x,y)=> bv1(y=> null==y? x: y, y);                                       // ^
  const wo = (x,y)=> x.filter(e=> !vv(y).includes(e))                                 // ^
  const l= x=> a(x)? 1: x.length;                                                     // #
  const tk= (x,y)=> x>0? y.slice(0,x): y.slice(x);                                    // #
  const dtk= (x,y)=> bv1(x=> y[x], x);                                                // #
  const rs= (x,y)=> {                                                                 // #
    let s=vv(x).slice(), l=rd((x,y)=>!y? x: x*y)()(vv(s)),                            //
      a=fl(vv(y)), ll=a.length, r=Array(l), t, i=s.indexOf(null);                     //
    if(i>=0){s[i]=Math.ceil(ll/(l=l||1)); l*=s[i];}                                   //
    for(let c=0; c<l; c++)r[c]=a[c%ll];                                               //
    for(let i=s.length-1; i>=0; i--){                                                 //
      const j=s[i]; t=[];                                                             //
      for(let k=0; k<r.length/(j||1); k++)t.push(r.slice(k*j,(k+1)*j)); r=t;          //
    } return r[0]||[];                                                                //
  }                                                                                   //
  const rep= (f,y)=> {                                                                // #
    let x=f(y), s=x.length===y.length? x: bv1(f, y);                                  //
    return [].concat(...s.map((e,i)=> Array(b(e)).fill(y[i])));                       //
  }
  const flr= x=> bv1(x=>Math.floor(x), x);                                            // _
  const lcs= x=> bv1(x=>x.toLowerCase(), x);                                          // _
  const drp= (x,y)=> x>0? y.slice(x): y.slice(0,x)                                    // _
  const del= (x,y)=> x.slice(0,y).concat(x.slice(y+1||x.length));                     // _, like tk, drp for y<0
  const cut= (x,y)=> x.map((e,i)=>y.slice(e,x[i+1]||y.length));                       // _
  const flt= (f,y)=> y.filter(!f);                                                    // _
  const str= x=> bv1(x=>x.toString(), x);                                             // $
  const pad= (x,y)=> sv(x=>x>0? y.padEnd(x): y.padStart(-x),x)                        // $
  const cst= (x,y)=>                                                                  // $
    x==="c"? String.fromCharCode(y):                                                  //
      x==="i"? sv(parseInt, y): x==="f"? sv(parseFloat, y):                           //
      x==="`"? y.join(""): x==="s"? y.split(""):                                      //
      (()=> {throw new Error("invalid type")})();                                     //
  const unq= x=> [...new Set(vv(x))];                                                 // ?
  const fnd= (x,y)=> bv1(x=>y.indexOf(x), x);                                         // ?
  const uni= x=> {let r=[]; while(r.length<x)r.push(Math.random()); return r;}        // ?
  const rnd= (x,y)=> {                                                                // ?
    let r=[]; while(r.length<Math.abs(x)){                                            //
      let n=Math.floor(Math.random()*y); if(x>0||!r.includes(n))r.push(n);            //
    } return r;                                                                       //
  }                                                                                   //
  const cal= (x,y)=> typeof x==="function"?x(y): x[y];                                // @
  const apl= (x,y)=> typeof x==="function"?x(...y): x(...y);                          // .
  const vls= x=> Object.values(x);                                                    // .
  const get= (x,y)=> x[y];                                                            // .
  const typ= x=> typeof x;                                                            // .

  // multi-adic
  const amd= (x,y,f)=> {let r=x.slice();r[y]=f(r[y]);return r}                        // @
  const am2= (x,y,f,z)=> {let r=x.slice();r[y]=f(r[y],z);return r}                    // @
  const drl= (x,y,f)=> {                                                              // .
    let r=x.slice(), a=y.slice(0,-1).reduce((e,i)=>e[i],r);                           //
    a[y[y.length-1]]=f(a[y[y.length-1]]); return r;                                   //
  }                                                                                   //
  const dr2= (x,y,f,z)=> {                                                            // .
    let r=x.slice(), a=y.slice(0,-1).reduce((e,i)=>e[i],r);                           //
    a[y[y.length-1]]=f(a[y[y.length-1]],z); return r;                                 //
  }                                                                                   //
  const tr= (f,y,g)=> {try {return f(y)} catch(e) {return g(e)}}                      // .
  const spl= (x,y,z)=> x.slice(0,y[0]).concat(z).concat(x.slice(y[1]))                // ?

  const vbs= {
    "+": [flp, add], "-": [neg, sub], "*": [fst, mul], "%": [srt, div],
    "&": [wh, min], "|": [rev, max], "<": [asc, lt], ">": [dsc, gt],
    "~": [not, mch], ",": [enl, cat], 
    "=": [x=>nump(x)? umt(x): grp(x), eql],
    "!": [x=>nump(x)||arrp(x)? od(x): k(x), (x,y)=>nump(x)&&nump(y)? dm(x,y): d(x,y)],
    "^": [nul,(x,y)=>arrp(x)&&arrp(y)? wo(x,y): fll(x,y)],
    "#": [l,(x,y)=>funp(x)? rep(x,y): arrp(x)||x>=0? rs(x,y): x<=0? tk(x,y): dtk(x,y)],
    "_": [x=>nump(x)? flr(x): lcs(x), (x,y)=> nump(x)&&arrp(y)? drp(x,y): 
      nump(y)&&arrp(x)? del(y,x): arrp(x)? cut(x,y): flt(x,y)],
    "$": [str,(x,y)=>nump(x)&&strp(y)?pad(x,y):cst(x,y)], 
    "?": [x=>nump(x)?uni(x):unq(x),(x,y)=>nump(x)? rnd(x,y): fnd(x,y)],
    "@":[typ,cal], ".": [vls,(x,y)=>funp(x)?apl(x,y):get(x,y)],
  }
  const advs = {
    "'": ec, "/": rd, "\\": sc, "/:": ecr, "\\:": ecl, "':": ecp
  }
  const ctx={}
  let sctx={}
  const name= Symbol("name")

  const tre= f=> {try {return f()} catch(e) {return f}}                         // try eval
  const nap= (f,x,y)=> y===undefined? x.t===name? ()=>f(sctx[x.v]): 						// name apply
  	f(x): x.t===name&&y.t===name? ()=>f(sctx[x.v],sctx[y.v]):
    x.t===name? ()=>f(sctx[x.v],y): y.t===name? ()=>f(x,sctx[y.v]): f(x,y);


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};
